---
layout: post
title: "[CS] Library"
subtitle: 정적 링크 라이브러리 & 동적링크 라이브러리(DLL)
author: Bonazoey
categories: CS
banner:
  image: "./assets/images/Agrt.gif"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold"
  subheading_style: "color: gold"
tags: [CS, Extension]
date: 2024-04-03 10:00:00 +0900
top: false
---

## Library

> 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임이다. 여기에는 구성 데이터, 문서, 도움말 자료, 메시지 틀, 미리 작성된 코드, 서브루틴(함수), 클래스, 값, 자료형 사양을 포함할 수 있다. (위키백과)

다시 말해서, 라이브러리는 **어떠한 기능이나 데이터를 하나의 단위로 묶어 놓은 자원**이다.

![image](https://github.com/bonazoey/bonazoey.github.io/assets/142956374/865d8c1f-0f6f-4e23-abed-121590094ccf)

예를 들어 내가 자동차를 만든다고 했을 때 누가 미리 만들어놓은 바퀴가 굴러가는 코드가 담긴 라이브러리가 있다고 치자, 그러면 나는 바퀴 외의 코드만 작성하고 Wheel.lib를 연결해 사용하면 된다.

마찬가지로 오토바이나, 자전거, 킥보드 등 Wheel.lib가 필요한 코드에 적용하여 사용할 수 있다. 라이브러리란 그런 것이다.

그리고 소스코드를 컴파일하게 되면 어떠한 `결과 파일`(\*.cpp)이 생성된다. 이 파일을 `실행 파일`(\*.exe)로 만들기 위해 소스코드 외적으로 라이브러리를 이용하게 되었다면 링크하는 단계를 거치게 된다.

링크는 `정적 링크`와 `동적 링크`로 나뉜다.

### Static Link

![image](https://github.com/bonazoey/bonazoey.github.io/assets/142956374/a28f4452-f728-4a02-9bd9-f73d130f1fc3)

`Static link`는 컴파일 시 **결과 파일(\*.cpp)** 과 **정적 라이브러리 파일(\*.a, \*.lib)** 을 합쳐서 하나의 실행 파일로 만든다.

그렇기 때문에 실행 파일 내에 라이브러리가 포함되어 있어. 이 파일만 실행하게 되도 다른 외부 파일이 필요하지 않다.

### Dynamic Link

![image](https://github.com/bonazoey/bonazoey.github.io/assets/142956374/43a2370c-43e6-4bbd-9528-25368ea74687)

`Dynamic link`는 컴파일 시 결과 파일인 실행 파일 내에 라이브러리 파일의 위치 정보만 담겨져 있다.

그렇기 때문에 실행 파일 밖에 **라이브러리 파일(\*.dll)** 이 따로 존재하며 파일이 실행될 때 `가상 메모리`에 할당되어 사용된다.

#### Management

동적 링크 라이브러리는 하나의 실행 파일 뿐만 아니라 여러 실행 파일에서 동시에 사용될 수 있는데 이 때 추가로 메모리에 올라오지 않고 가상 메모리에 이미 올라와있다면 그걸 쭈욱 사용한다.

하지만 코드는 공유할 수 있지만 실행 파일마다 ***데이터는 공유하지 않는다.*** A 파일에서 라이브러리를 이용해서 변경한 데이터가 B 파일에 영향을 주진 않는 것이다.

(약간 싱글톤 패턴 느낌)

이 때 동적 라이브러리는 사용하는 실행 파일의 개수에 따라 카운트를 하게 되며 파일이 추가될수록 +1, 실행이 종료 되면 -1 값을 처리하게 된다.

그러다 카운트가 0이 되면 그때 라이브러리가 메모리에서 삭제된다.

| A.exe 실행 | B.exe 실행 | C.exe 실행 | A.exe 종료 | C.exe 종료 | B.exe 종료 |
| --- | --- | --- | --- | --- | --- |
| dll 로드 ||||| dll 삭제 |
| cnt = 1 | cnt = 2 | cnt = 3 | cnt = 2 | cnt = 1 | cnt = 0 |

#### Link type

##### Implicit link

암시적 연결은 해당 함수가 어느 dll에 있는지 밝히지 않고 사용한다. 프로젝트에 임포트 라이브러리를 포함해야하고 Windows는 라이브러리 정보를 참조해 알아서 dll을 로드하고 함수를 찾는다.

클라이언트 프로그램이 로드될 때 dll이 로드 되거나 이미 로드 돼있으면 카운트를 1 증가시킨다.

클라이언트 프로그램 실행시 dll이 로드 되므로 `실행시 연결`이라고 한다.

> 임포트 라이브러리 dll 파일 찾는 순서
> 
> `클라이언트 프로그램이 포함된 dir > 프로그램 현재 dir > 윈도우의 시스템 dir > 윈도우 dir > PATH 환경 변수가 지정하는 모든 dir`

만약 원하는 dll를 찾지 못 하면 에러메세지를 출력하고 실행이 종료된다.

##### Explicit link

명시적 연결은 필요할 때만 dll을 읽어서 사용한다. 그렇기에 암시적 연결에 비해 메모리가 절약된다. 또 경우에 따라 dll을 교체할 수 있고 원하는 dll로 선택해 사용할 수 있다.

원하는 dll이 없어도 프로그램 실행이 가능하며 dll이 필요한 작업은 수행하지 못 하지만 프로그램 실행 자체는 가능하다.

또한 프로그램 실행시 dll을 읽을 필요가 없어서 dll을 읽고 시작하는 암시적 연결과 달리(몇 십개씩 로드 할 수도 있다.) 빠른 실행 속도를 보여준다.

### 장단점

|| Static link | Dynamic link |
| --- | --- | --- |
| 장점 | 실행 파일을 단독으로 실행 할 수 있다. 실행 파일에 함수 코드가 포함돼있어 컴파일이 끝나면 lib 파일이 필요 없이 실행가능하다. | 실행 시 함수의 정보만 갖고 있으므로 파일 크기가 작아진다. 교체가 가능하고 혼합프록래밍이 용이하며 분담 작업에도 용이하다. |
| 단점 | 코드가 포함 돼있기 때문에 실행 파일 크기가 상대적으로 커진다. | 실제 코드를 갖고있지 않기 때문에 실행시 dll이 꼭 있어야한다. |
